-msalvadorrol

-Manuel Salvador Roldán

**-PEC2_Ej1_1:** Para este primer ejercicio, la clave ha sido comprender y leer documentación de Typescript para entender la importancia de este lenguaje y sus posibilidades y extensiones frente a Javascript. 

**-PEC2_Ej2_1:** En este segundo ejercicio, se han ido completando las diferentes modificaciones del array original para que el resultado sea el oportuno. Para comprobar que se ha realizado correctamente, hemos compilado el TS realizando un tsc ejercicio1.ts e indicando en el tsconfig.json la entrada y salida de archivos y realizado desde la consola de Visual Studio Code un node ejercicio1.js. Hacemos lo mismo con el ejercicio2.ts, solo que en este caso, al realizar más pruebas, se ha activado el modo --watch para que la compilación a JS sea automática (tsc ejercicio2.ts --watch). Para el último ejercicio, repetimos el --watch, y en este caso lo que vamos a tener que definir es tanto el sonido en cada animal como la herencia de la clase padre Animal. Deberemos, pues, definir el constructor en la clase padre y pasarle dos argumentos optativos, ya ambas usan un argumento diferente. Lo pasamos con constructor y super a las hijas y luego recorremos ambos elementos del array atendiendo a la instancia a la que pertenezcan con instanceof.

**-PEC2_Ej3:** Para el último ejercicio, lo primero que he realizado es analizar el código y entenderlo, siguiendo la arquitectura MVC. Para comenzar el proyecto, es necesario reorganizar la estructura de carpetas y utilizar Typescrit desde el terminal, donde ejecutaremos esta extensión. A continuación, dividiremos el js y el ts: la carpeta de src para el TS, y dist para compilar la aplicación, y configuramos el archivo tsconfig para que la entrada y salida se corresponda con dichas carpetas. 
Para cambiar el archivo de model, hemos modificado el constructor y especificado los tipos de las variables; sin embargo, el codigo de generar la id chocaba con la configuración de TS. La forma más sencilla de solucionarlo ha sido instalar el paquete de uuid (https://www.npmjs.com/package/uuid#support), y generar así la id sin problemas.
En cuanto al archivo de services, hemos importado la interfaz y la clase de Todo. De esta forma, aseguramos que la variable todos creada en la clase TodoService tenga la información necesaria especificada en la interfaz Todo. Cambiamos y tipamos todas las variables utilizadas en esta clase. Es necesario hacer un cambio en la interface de ITodo: cambiamos el id a opcional. Esto es porque cuando añadimos un Todo nuevo, no querermos pasarle un id desde la clase, porque este id lo estamos generando con un método dentro de la clase Todo. Si no lo pusieramos opcional, nos veríamos obligados a especificarle un id desde la acción de añadir una tarea, cosa que no queremos.
Para el todo.view, necesitamos declarar todas las variables como elementos HTML dentro del DOM. Vamos a encontrarnos con que, a la hora de manipular el DOM con los event listeners, deberemos volver a declarar que estos elementos, en este caso representados por entry.target, son efectivamente elmentos del DOM. Declarados los elementos HTML y tipados los listeners, pasamos al handler los datos correspondientes del elemento, ya sean la id, string porque se cambie el texto, etc. 
Finalmente, con el controler, lo que vamos a hacer es unir todos los elementos de la aplicación. Por ello debemos de importar las clases utilizadas y la interfaz del ITodo. De nuevo, deberemos especificarle a los handlers qué tipo de dato les estamos pasando, terminando así de especificar los tipos en los archivos de .ts

A la hora de compilar el proyecto, el proceso que hemos seguido ha sido ejecutar desde el terminal el comand o 'npx tsc' en el directorio de las carpetas de typescript. Ahora tendremos el .ts compilado en la carpeta /dist. Accedemos a index y comprobaremos que, efectivamente, todo el proyecto se ha compilado correctamente.